[ { "title": "Thoughts and Excerpts on AI-Assisted Programming", "url": "/posts/ai-en/", "categories": "AI", "tags": "AI, Coding", "date": "2025-09-26 00:00:00 +0800", "snippet": "Mindset Future Chatting with VSCode core developer Lu Peng about AI programming, Vibe Coding, and whether programmers will still exist in the future Writing programs is like riding a horse; we are the last generation of horse riders. DHH: Future of Programming, AI, Ruby on Rails, Productivity &amp; Parenting no one knows anything, and you have to then position yourself for the future in such a way that it doesn’t matter. you pick a professional path where if it turns out that you have to retool and re-skill, you’re not gonna regret the path you took. There will be more one-off code in the future. Vibe Coding Vibe-coding is not the same as AI-Assisted engineering. good example of AI-Assisted engineering (not vibe coding actually) Not all AI-assisted programming is vibe coding (but vibe coding rocks) Using “Vibe coding” to build a real product won’t work. But it’s great for prototyping. AI won’t kill software engineering; instead, it makes the old rules of software engineering great again. In the era of AI-assisted programming, automated software testing is becoming increasingly important. Vibe Coding Is Creating Braindead CodersTechSpec-Driven Development https://github.com/github/spec-kitAdvice Study with AI GenAI policy in Berkeley CS 189 2025 Fall &amp; jyy OS 2025 Spring For repetitive or formulaic code, like data visualization, you can directly tell the large model what kind of chart you want and let it generate it for you. But for the core model implementation and algorithm logic, it’s best to write it yourself to greatly enhance your understanding. Source (2025.9.19) Use GPT-5-high for more macro-level planning, and GPT-5-Codex for specific technical implementation. Use git worktree for parallel tasks. Related command-line tool xlaude and its workflow sharing.Prompt (2025.9) How OpenAI uses Codex (2025.8) Claude Code: A Highly Agentic Coding Assistant (2025.7)【Official Anthropic Share】Prompt Engineering Techniques Example of calling Gemini in Claude Code: Q: “Please have gemini-2.5-pro comment on each section, mainly to add content.” How is this implemented? Calling other models in the code? A: Example given: gemini -p \"In-depth answer: &lt;question&gt;\" -m gemini-2.5-pro. CC can understand what “Please have gemini-2.5-pro \" means. Feed https://x.com/dotey https://baoyu.io/ AI News Daily 【rss】Status 2025.9 At the 2025 ICPC World Finals, OpenAI’s general-purpose reasoning system achieved an unprecedented score of 12/12, defeating all human teams. Source 11 problems were solved on the first attempt, and the final, most difficult problem was solved using GPT-5 + an experimental reasoning model. DeepMind’s Gemini 2.5 Deep Think model also performed well, solving 10 out of 12 problems. “70%, 80%, or even 90% of Anthropic’s code is written by Claude. People think this is false because they think it means firing 70%, 80%, or 90% of software engineers, but what’s really happening is that humans are becoming managers of AI systems.” Source " }, { "title": "对AI辅助编程的思考和摘录", "url": "/posts/ai/", "categories": "AI", "tags": "AI, Coding", "date": "2025-09-19 00:00:00 +0800", "snippet": "Mindset Future 和 VSCode 核心开发吕鹏聊 AI 编程、Vibe Coding、未来程序员还是否存在 写程序～骑马的人，我们是最后一代骑马的人 DHH: Future of Programming, AI, Ruby on Rails, Productivity &amp; Parenting no one knows anything, and you have to then position yourself for the future in such a way that it doesn’t matter. you pick a professional path where if it turns out that you have to retool and re-skill, you’re not gonna regret the path you took. 未来会有更多的一次性代码。 Vide Coding Vibe-coding is not the same as AI-Assisted engineering. good example of AI-Assisted engineering (not vibe coding actullay) Not all AI-assisted programming is vibe coding (but vibe coding rocks) 想用“凭感觉编程（Vibe coding）”来打造一款真正的产品，是行不通的。但用它来做原型，那简直太棒了。 AI 杀不死软件工程，反而使软件工程的那些古老规则再次伟大。 在 AI 辅助编程的时代，自动化软件测试正变得越来越重要。 Vibe Coding Is Creating Braindead CodersTechSpec-Driven Development https://github.com/github/spec-kitAdvice 长时间运行 Codex/Claude Code 的方法： spec-kit -&gt; 生成合适的 task.md Claude Code 监督 Codex 通过脚本监督 claude-code-auto 让 Claude Code 24小时无限工作，自主决策下一步行动。 用 Warp 作为编排器来调度多个 coding agent Study with AI GenAI policy in Berkeley CS 189 2025 Fall &amp; jyy OS 2025 Spring 一些重复性高或模式化的代码，比如数据可视化，可以直接告诉大模型你想要什么样的图，让它帮你生成。但核心的模型实现、算法逻辑，最好还是自己亲手写一遍，这样能大大增进你的理解。【来源】 (2025.9.30) Claude Sonnet 4.5 能感知自身上下文窗口并因此产生“焦虑”（比如过早总结、走捷径），可以启用一个远大于实际需求的上下文窗口（例如，开启1M token容量但将使用上限设为200k）。这能让模型感觉“空间充裕”，从而避免其因担心超出限制而降低工作表现。【来源】 (2025.9.19) 使用 GPT-5-high 做较宏观的规划，用 GPT-5-Codex 进行具体技术实现。 并行任务使用 git worktree。 相关命令行工具 xlaude 及其工作流分享。Prompt (2025.9) Context engineering (2025.9) How OpenAI uses Codex【中文翻译】 (2025.8) Claude Code: A Highly Agentic Coding Assistant (2025.7)【Anthropic官方分享】Prompt提示词工程技巧分享 在 Claude Code 中调用 Gemini 的示例： Q: “请 gemini-2.5-pro 评论一下各节，主要是要增加内容 “这是怎么实现的呢？在code里调用其他模型？A: 给出示例 gemini -p “深入回答：&lt;要问的问题&gt;” -m gemini-2.5-pro。 CC 能看懂并知道什么叫”请 gemini-2.5-pro”&lt;要问的问题&gt; MCPChrome DevTools MCPFeed https://x.com/dotey https://baoyu.io/ AI资讯日报 【rss】Status 2025.9 在 2025 年 ICPC 世界总决赛中，OpenAI 的通用推理系统实现了前所未有的成绩——满分 12/12，击败了所有人类参赛队伍。【来源】 其中11题一次通过，最后一道最难题使用 GPT-5 + 实验性推理模型解出。 DeepMind 的 Gemini 2.5 Deep Think 模型也表现出色，成功解出12题中的10题。 “Anthropic 70%、80% 甚至 90% 的代码都是由 Claude 编写的。人们认为这是假的，因为他们觉得这意味着要解雇 70%、80% 或 90% 的软件工程师，但真正发生的是，人类变成了 AI 系统的管理者。” 【来源】 " }, { "title": "关于学习", "url": "/posts/study/", "categories": "Study", "tags": "Study", "date": "2025-08-20 00:00:00 +0800", "snippet": "Map https://www.zhihu.com/people/L.M.Sherlock 自主学习 各种领域学习的方法的翻译集合 Facts约翰·邓洛斯基（John Dunlosky）为首的五位著名心理学家在2013年系统性地评估了十种常见的学习方法，并根据证据的强度将其分为高效、中效和低效三类【pdf】【talk with gemini】： 效能等级 学习方法 核心理念 高效 1. 练习测试 (Practice Testing) 主动提取信息，而非被动输入 高效 2. 分散式学习 (Distributed Practice) 间隔复习，对抗遗忘曲线 中效 3. 精细化提问 (Elaborative Interrogation) 通过问为什么，建立知识连接 中效 4. 自我解释 (Self-Explanation) 用自己的话解释，监控理解 中效 5. 交叉学习 (Interleaved Practice) 混合练习不同主题，提升迁移能力 低效 6. 总结 (Summarization) 技巧要求高，易沦为无效摘抄 低效 7. 划线/标亮 (Highlighting/Underlining) 被动行为，易产生学习错觉 低效 8. 关键词助记法 (Keyword Mnemonic) 适用范围极窄，联想脆弱 低效 9. 文本意象化 (Imagery for Text) 仅适用于易于视觉化的内容 低效 10. 反复阅读 (Rereading) 最易产生学习错觉的被动方法 Anki Workflow Anki 知乎知识库-知识表述与制卡原则 Obsidian Obsidian_to_Anki AI prompt for making flashcardsReference 间隔重复、交错练习、测试效应的科学依据" }, { "title": "【转载】mock七宗罪", "url": "/posts/mock/", "categories": "Test", "tags": "Test", "date": "2024-07-06 00:00:00 +0800", "snippet": " 转载者注：原文所在的gitchat现在已经打不开了，虽搜不到任何倒闭的消息，但app已经不存在了，23年后也没任何新闻了。网页地址会重定向到CSDN，但又无法在CSDN上搜索到全文的链接和肖鹏的账户。从互联网归档网站上查看了历史也只能看到前言或者简介。所幸，从一个资料网站上找到有人上传的“格式感人，但内容都保留下来”的pdf版本，付费10元买之，并简单重新排版后备份存档，一些小错误就不再费心了（莫名其妙的空白，丢链接，warehouse变成了wa house）。作者：肖鹏，ADP技术与解决方案架构师，前ThoughtWorks持续交付中国区Lead。目前专注于响应式编程，以及企业系统集成与容器化。Mock天虹大酒店2层小会议室门前，我看了看表1点59分。敏捷大会讲师论坛，下午我第一个发言，题目是“你用错了Mock”。我走进会议室的一瞬间，清晰地感觉到了各位讲擦掌准备把我批个体无完肤。“在我开始发言之前，我想强调一下我不是针对在座的哪一位。”我说道，“我是说我们每个人都用错了。”我做培训的时候经常在开始玩一个自创的游戏。首先我一段，里面我用手指有节奏的敲桌子。然后让听众猜我敲击的节奏是来自于那首歌。听众被分成两组，一组完全盲听，第二组知道这首歌是《祝你生日快乐》、《》、《卖报歌》中的一首。我做过很多次实验，第二组大概有80%以上的几率猜对，第一组则从来没有猜对。在被告知答案之后，第一组的人也觉得很明显。通过这个游戏，我想告诉我的听众，在我的培训中你不会学到任何新的东西， 唤醒你已有知识和思考。同时，每个人从中得到的也是不一样的，这取决于你已有的知识结构和思考方式。为什么要花那么大篇幅引入今天的主题呢？因为这是一个反直觉的主题。如果我们没在一个频道上，这将是一场互相的伤害。如果你完全没有用过Mock，你几乎什么也不会得到。背景在下面的论述中，我们尽可能使用同一个案例^。我们所列举的每一个情形都是来自于我本人参加的开发项目或者咨询项目。为了便于理解和陈述，我们把它映射到这个案例上面。 该案例取自Martin Fowler先生的Mocks Aren’t Stubs。我们有一个订单（Order） 对象， 该对象从仓库（Wareouse） 对象中取出产品（Product）。订单对象仅包含一个产品对象和该产品的数量。仓库对象中包含多种不同的产品及其数量。当订单对象试图从仓库中取出产品并填充(fill)自己的时候，有两种结果。如果仓库中有足够的产品，订单填充成功，同时仓库中产品减少相应的数量。否则订单填充失败，并且仓库保持不变。//产品代码（仅Order类）public class Order { private final String product; private final int quantity; private boolean filled; public Order(String product, int quantity) { if (quntity &lt;= 0) throw new InvalidArgumentException(\"The quantity shall not equal or be less than 0.\"); this.product = product; this.quantity = quantity; } public void fill(Wa ouse wa ouse) { if(warehouse.hasInventory(quantity)) { warehouse.remove(quantity); filled = true; } } public boolean isFilled() { return filled; }}第一部分：Mock测试的缺陷在开始谈缺陷之前，我们先来看一下Mock测试主要解决什么问题？以下内容来自Wiki，括号中的注释略有修改：如果一个对象具有以下特征，比较适合使用mock对象： 该对象提供非确定的结果（比如当前的时间或者当前的温度） 对象的某些状态难以创建或者重现（比如网络错误或者文件读写错误） 对象方法上的执行太慢（比如在测试开始之前初始化数据库） 该对象还不存在或者其行为可能发生变化（比如测试驱动开发中驱动创建新的类） 该对象必须包含一些专门为测试准备的数据或者方法（后者不适用于静态类型的语言，流行的Mock框架不能为对象添加新的方法。Stub是可以的。）当我们讲到缺陷的时候，一定是说它相对于其他的解决方案。这里我们对比的是直接使用真实对象（Object）的测试，比如不使用Mock的单元测试和集成测试。一个典型的Mock测试是这样的：//测试代码public class OrderTest { private static String TALISKER = \"Talisker\"; @Test public void testFillingRemovesInventoryIfInStock() { //设置数据 Order order = new Order(TALISKER, 50); Wa ouse wa ouse = mock(Wa ouse.class); when(wa ouse.hasInventory(50)).thenReturn(true); //执行被测逻辑 order.fill(wa ouse); //验证 verify(wa ouse, times(1)).hasInventory(50); verify(wa ouse, times(1)).remove(TALISKER, 50); assertThat(order.isFilled(), is(true)); }}被测对象，也经常称为SUT（System Under Test），为真实对象，而其依赖则被完全隔离。借用精益方法中常用的湖水岩石的比喻：岩石代表被测对象及其依赖，水面代表Mock界面。水面以下的部分都被Mock掩盖了。然而，我们的测试是应当确保整个系统正常工作的。由于Mock框架强大的灵活性，这个水面几乎可以任意设置。即便是纪律性非常好的团队， 也很难在这个问题上做到一致。比如可以Mock Repositories ， 也可以MockService，甚至Mock一个简单的POJO。这时候确实水面以上的部分被测试覆盖到了，水面以下的部分呢？1.阻碍重构重构是敏捷开发最重要最基本最常用的实践之一。但是Mock测试却经常给重构带来的障碍。这个测试现在是通过的。考虑到fill 方法中关于hasInventory 的检查是属于Warehouse 的细节，我们尝试把它移动到Warehouse 类中。// Order classpublic void fill(Wa ouse wa ouse) { filled = tryRemove(wa ouse);}// Wa ouse classpublic boolean tryRemove(String product, int quantity) { //这个判断可以简化，但是为了说明问题，保持原来的调用逻辑 if(hasInventory(quantity)) { remove(product, quantity); return true; } return false;}重构的基本原则就是对外表现的行为不变，那么相应的，在做重构的时候我们不应当需要修改测试。完成这个重构之后，你会发现测试失败了。即便是我们在tryRemove 中调用了一样的逻辑，对于被测试它也是不可见的。因为要重构所以要修改测试绝对不是什么好主意，你怎么知道你没有修改行为呢？实际上有几种重构手法是天然的跟Mock测试水火不容的。比如inline , Mock 说“嗨，我来设置这个函数的行为”； inline 说“不用了，我已经把它消除了”。类似的重构还有在类之间迁移方法、上推或者下移方法等等。基本上除了重命名这类简单的重构，你会发现你的实现被绑死在测试上了。在我看来这一条罪状足够了，只要我还能找到其他替代的方式（第二部分介绍），我就不会用Mock了。2.掩盖坏味道Mock不仅会阻碍重构本身，同时也会提高团队对于坏味道的容忍程度。Mock的根本驱动力是构建实际对象的困难。而构建实际对象的困难往往本身就意味着某种坏味道。常见的情形是，一个类有过多的依赖。当你要在测试中创建这样的类的时候你会发现仅仅构建这样一个类的实例就是很复杂的。所以，不如用到哪个方法就Mock哪个方法。于是，对于违反了单一职责原则的对象团队往往不能在测试时感受到对象创建的困难。也就缺乏动力进行重构。另一种情形是过长的调用链。对于过长的调用链，Mock方案是非常具有吸引力的（想象一下在remove 方法中有一长串的getA().fetchB().buildC().delete() ） 。因为你可以只Mock 第一级调用( remove )，测试写起来是不是容易多了。在一个恰当的设计中，每一级调用应当是其实现细节的抽象。当我们使用过长的调用链的时候实际上是把下一级的实现细节了。我的原则是把对框架（或者库）函数的调用定义为边界，任何一个方法到达边界的距离应当尽可能的短（3~4步是我的上限）。过深的的调用意味着对下层函数进行修改的时候涟漪效果会更加明显。这个时候我们应当做的是改善设计而不是用Mock掩盖错误。3.测试实现细节等等，单元测试不就是测试细节的吗？[捂脸哭]GitChat对于表情符号支持不太完善，请自动脑补捂脸哭的符号。是的，单元测试是测试细节的，但是测试测试的是业务的细节，而不是实现的细节。还是以上文中的代码为例， fill 方法到底是调用了Wa ouse 的哪个方法就是实现细节。从测试的目的看，任何测试都应该是行为测试或者业务逻辑测试。即我们测试的是系统或者组件有没有按照期望的方式返回结果。至于这个结果是怎么产生的不应当是测试负责验证的事情。值得指出的是，业务逻辑是层层下放的，也就是上一层的所有业务细节，一定在下一层有支撑。而一般情况下每一个方法一定是应对于一个业务需求（粒度大小不同）。从投入产出比来看，为什么不要测试实现细节呢？实现细节变化快于其实现的业务变化频率，测试成本高；同时，因为测试没有到达“边界”，实际上我们获得的信心是有限的。使用Mock测试的时候，我们经常会发现测试基本上是在重复实现的逻辑（比如上文中的测试，你必须知道实现的时候使用了那个方法，才能对那个方法进行Mock）。4.漏测关键逻辑案例背景：我们需要计算当天的Order 的总数量。我们为Order类增加一个日期field，并创建OrderService 类来实现计算。@Testpublic void sum_total_amount_of_orders_for_today(){ // today, yesterday, tomorrow Order yesterdayOrder = new Order(TALISKER, 100, yesterday); Order todayOrder1 = new Order(TALISKER, 200, today); Order todayOrder2 = new Order(TALISKER, 600, today); Order tomorrowOrder = new Order(TALISKER, 800, tomorrow);when(orderReporsitory.findByDate(eq(today))).thenReturn(ArrayList.asList(todayOrder1, todayOrder2)); // orderReporsitory通过依赖注入的方式注入到OrderService中 assertThat(orderService.getTodaysAmount(), is(800)));}public class OrderService { Integer getTodaysAmount() { Date today = new Date(); List orders = orderReporsitory.findByDate(today); // 对orders的数量进行求和并返回 ... }}由于我们在数据库中保存的时间是不带时区的，而在orderService 中的today 却是根据操作系统的时区得到的。这就导致搜索得到的结果是跟系统运行的时区设置有关。这是一个非常常见的测试错误，表面上我们测试了getTodaysTotal 的逻辑。但是实际上，操作系统时区这个关键逻辑被掉了。任何时候都要小心，被Mock的对象其行为未必跟我们预期的一致。5.测试不存在的逻辑怎么可能测到不存在的逻辑！我隔着屏幕都能感觉到你的疑惑。我们来看下面这个例子：@Test(expect = IllegalStateException.class)public void throw_exception_if_an_order_has_no_product_set(){ Destination mockedOrder = mock(Order.class); when(mockedOrder.getQuantity().thenReturn(0); ordreService.validate(mockedOrder);}public class OrderService { void validate(Order order) { if (order.getQuantity() &lt;= 0) { throw new IllegalStateException(\"Order has invalid quantity set.\") } }}看上去没什么问题，可是事实上Order 的构造函数可能就已经任何成功构建的实例其quantity 都不会为0。如果你使用的是真实的对象，是根本不可能犯这个错误的。6.测试可读性差应当承认现在的Mock框架的语法已经变得比几年前要好得多了。在jMock ，被方法名还是要以字符串的形式出现。感受一下这个：warehouseMock.expects(once()).method(\"hasInventory\") .with(eq(TALISKER),eq(50)) .will(returnValue(true));新的语法仍然有很多奇怪的限制。比如， 这个是不合法的verify(wa ouse, times(1)).remove(anyString(), 50); ， 必须写成verify(wa ouse, times(1)).remove(anyString(), eq(50)); 。另外，你有没有想过下面三种方式有没有差别：//方式1when(wa ouse.hasInventory(50)).thenReturn(true);//方式2boolean methodCall = wa ouse.hasInventory(50);when(methodCall).thenReturn(true);//方式3boolean methodCall = wa ouse.hasInventory(50);wa ouse.hasInventory(30);when(methodCall).thenReturn(true);我是直到看了Mockito的源代码才明白为啥方式1和方式2等价，方式3会失败。我建议你也去看一下它的实现，确实非常巧妙，但是也增加了很多限制。你可以说这些都是为了提高可读性，但是它增加了很多需要记忆的东西。7.掩盖性能缺陷案例：下面这段代码，首先根据country 从缓存中取得相关的订单的ID，然后取出所有订单并计算总金额。public Integer amount getTotal(String country) { List&lt;Id&gt; ids = orderCacheService.getAllIds(country); Integer total = 0; for(Id id : ids) { total += orderReporsitory.getOrder(id).getAmount(); } return total;}虽然我们在测试中包含了对于100K+ ID的测试（当时是为了测试缓存），后来我们发现这个函数在线上平均执行时间为~2000秒（大于半个小时）。而、在测试中由于我们Mock了getOrder 方法，忽视了数据库本身的性能。第二部分：不用Mock怎么写（单元）测试我合作过的很多团队，特别是敏捷团队，都对Mock情有独钟。有些团队甚至达到了无Mock不UT的地步。2013开始我在团队中开始推行去Mock化，并取得了不错的效果。下面是我总结的一些经验。1.消除“单元”情结要在团队中推行去Mock，就要消除“单元”情结，或者换个角度看待“单元”这个概念。这往往是一个长期的过程，但是第一部分应该给你提供了大量的。Mockist（Mock主义分子）往往重视单元的隔离性。 A mockist TDD practitioner, however, will always use a mock for any object with interesting behavior.——Martin Fowler在他们看来单元测试就是测试一个类，甚至是一个方法。所有其他的因素全都应当掉。这不仅在原则上是错误的，第一部分也论证了在实践上也是不可能的。正确的测试单元应当是一个业务逻辑单元，比如： 用户必须提供正确的邮件地址才能注册 用户的默认地址可以被当前地址覆盖 用户无法取消正在执行中的工作流你的测试本身，而不仅是测试的方法名，应该是对于非开发也尽量是可读的。@Beforepublic void setUp() throws Exception { wa ouse.add(TALISKER, 50); wa ouse.add(HIGHLAND_PARK, 25);}@Testpublic void testOrderIsFilledIfEnoughInWa ouse() { Order order = new Order(TALISKER, 50); order.fill(wa ouse); assertThat(order.isFilled(), is(true)); assertThat(wa ouse.getInventory(TALISKER), is(0));}你会发现有些代码会在不同的测试中被重复执行，比如对邮件地址的格式可能经常被不同的测试覆盖到。这会带来一定的测试效率降低，但是实际开发中因为对象的创建而导致测试效率下降的情况少之又少。2.文件、网络和数据库当我们谈起什么时候“应当”使用Mock的时候，IO及其相关操作往往是最先被提出来的。这是因为牵扯到IO的操作往往一方面对象的创建成本高（比如DB connection），另一方面操作执行的速度相对于在内存中创建对象要低得多。对于数据库我通常采用的策略是使用内存数据库，比如H2。Mock数据库层的风险是非常高的。因为现代的数据库有大量的逻辑在里面————SQL、锁、事物等等。关于网络，首先Controller(或者有的框架推荐叫Resource)是可以脱离网络进行测试的。针对对Web Service （ 比如RESTful API ） 的测试的是测试请求的分发（Dispatch），这个时候把服务器跑起来通常是最经济的。好在有内存数据库帮忙，跑起一个服务器并不是很困难的事情。可以参考JHipster的实现。内存文件系统有Google出品的Jimfs。这个我用的比较少，因为大多数情况基于文件的内容做测试就够了。真正读写文件的时候处理好已知的异常即可。3.考虑其他的Test Double方式我在实际工作中也不是完全不使用Mock。如果一个对象比较困难创建，我也会先从Mock开始，测试通过以后逐步把它变成对真实对象的测试。我选择尽量不提交Mock到中心库。在使用Mock的时候我也尽量把它作为Stub使用。比如一开始的例子，我一般都不verify被依赖对象的行为，而只是检查对被测对象的状态（isFilled）。我发现这样可以让测试相对的容易理解，并且不那么脆弱。@Testpublic void testFillingRemovesInventoryIfInStock() { //setup - data Order order = new Order(TALISKER, 50); Wareouse wareouse = mock(Wareouse.class); when(wareouse.hasInventory(50)).thenReturn(true); //exercise order.fill(wareouse); //verify assertThat(order.isFilled(), is(true));}我自己使用Stub的时候并不多（因为我发现如果遵循SRP的原则实际对象通常都很容易创建和装配）。在我看来通过扩展（extend）原对象的方法来生成Stub也比Mock要好，因为这样你关注的是状态，而不是两个对象的交互细节。Spies也是一个替代方案它是Stub的一种实现。具体的的定义可以参考Martin Fowler的文章Mocks Aren’t Stubs。4.尝试Reactive Programming严格的讲这一点并不是解决Mock测试的问题，而是整体上减少有状态的类。我在使用了响应式编程之后发现需要Test Double的机会降低了。因为响应式编程鼓励尽量避免副作用（Side Effects），这使得一个方法几乎不会对外产生依赖。如果有依赖，也是另一个无副作用的依赖。对于一个Function来说，一个输入无条件的对应一个确定的输出。所以，我们设计的方法往往能很快到达“边界”。在纯粹的Functional Programming 不存在面向对象意义上的“对象”的。用户可以定义数据结构，其目的是作为参数或者结果，而不是将操作和作的数据放到一起（就像面向对象的做法）。从面向对象编程转向响应式编程在思维方式上是一个非常大的转变。我们也不能针对一个用面向对象思维设计出来的类（比如Order）以响应式编程的方式进行测试。总结我们通过一系列案例分析了使用Mock的时候带来的问题。其问题是不能给团队提供足够的信心。根本原因则是系统被Mock的部分不一定会按照我们设想的方式工作。最后我们给出了几个避免或者减少使用Mock的几个策略。" }, { "title": "Latex编写跨页长表格报告的踩坑经历", "url": "/posts/latex-proposal-summary/", "categories": "Latex", "tags": "Latex", "date": "2024-06-08 00:00:00 +0800", "snippet": "具体latex项目示例见github仓库ECNU-Thesis-Proposal，下面是一些踩坑的总结。简单跨页长表格使用mdframed包适合实现下图可跨页的简单表格样式，且在单元格内依旧像正文一样，方便得调整样式和正常使用 figure,enumerate等功能，不需要额外的调整样式去匹配。这些是普通的表格 tabularx和 跨页表格（longtable、 xltabular）很难方便做到的。示例\\mdfdefinestyle{mymdfstyle}{ everyline=true, linewidth=0.5pt, innerleftmargin=4pt, innerrightmargin=4pt, innertopmargin=-15pt, innerbottommargin=-10pt}\\begin{mdframed}[ style=mymdfstyle,]% 第一个单元格的内容% 使用 \\mdfsubtitle 添加横行，区分单元格\\mdfsubtitle[ subtitleaboveline=true, subtitleabovelinewidth=0.8pt, % 经验值，肉眼看跟上面 linewidth = 0.5pt 粗细差不多 subtitlebelowskip=0.2\\baselineskip, subtitleinneraboveskip=0pt, subtitleinnerbelowskip=0pt,]{}% 第二个单元格的内容\\end{mdframed}图片tikz画图初探 手册 mathcha - 在线画图工具 TikZ and PGF examples (texample.net) literature survey taxonomy tree： LaTreeX (lautgesetz.com)-在线生成tree图片或latex源码网站 How to Draw a Literature Survey Taxonomy Tree in Latex - Roy’s Blog 强制图片位置\\usepackage{float}\\begin{figure}[H]...\\end{figure}列表简单列表一、第一项二、第二项三、第三项\\begin{enumerate}[label=\\chinese*、] \\item 第一项 \\item 第二项 \\item 第三项\\end{enumerate}多级列表- 开发组 - 数据层 --- 前期2位同学，后期1位同学 - 主要负责数据的采集、抽取以及入库等（需要了解neo4j）。 - 前端 --- 1位同学 - 主要负责功能界面的可视化（需要了解node.js）。 - 后端 --- 1位同学 - 主要负责业务逻辑。- 研究组\\begin{enumerate} \\item 开发组 \\begin{enumerate} \\item 数据层 --- 前期2位同学，后期1位同学 \\begin{itemize} \\item 主要负责数据的采集、抽取以及入库等（需要了解neo4j）。 \\end{itemize} \\item 前端 --- 1位同学 \\begin{itemize} \\item 主要负责功能界面的可视化（需要了解node.js）。 \\end{itemize} \\item 后端 --- 1位同学 \\begin{itemize} \\item 主要负责业务逻辑。 \\end{itemize} \\end{enumerate} \\item 研究组\\end{enumerate}每一级不同样式的多级列表第一章 第一级项目 1.1 第二级项目 1.1.1 第三级项目 1.1.2 第三级项目第二章 第一级项目\\setlist[enumerate]{itemsep=0pt}\\setlist[enumerate,1]{label=第\\chinese*章,itemindent=20pt}\\setlist[enumerate,2]{label=\\arabic{enumi}.\\arabic*,itemindent=-5pt}\\setlist[enumerate,3]{label=\\arabic{enumi}.\\arabic{enumii}.\\arabic*}\\begin{enumerate} \\item 第一级项目 \\begin{enumerate} \\item 第二级项目 \\begin{enumerate} \\item 第三级项目 \\item 第三级项目 \\end{enumerate} \\item 第一级项目 \\end{enumerate}\\end{enumerate}% 恢复默认\\setlist[enumerate]{}\\setlist[enumerate,1]{}\\setlist[enumerate,2]{}\\setlist[enumerate,3]{}工具 overleaf - 在线编写latex网站，有很多现成的模版，如华师大毕业论文模版和ppt模版； Detexify - 根据鼠标画出来的形状去搜索相近的符号及其对应的latex代码。后记官方开题报告使用了一个跨页长表格来填充内容，也是开坑的起点。一开始基于上海交大开题报告模板，修改制作latex模版时，用了错误的xltabular包，导致写的时候失去了latex自动化的优势，反而耗费了很大的功夫去全手动的写东西。四分之一时间在写报告，剩下的时间全在调格式debug。急急忙忙交完了报告后，回过头看，发现了非常合适的mdframed包，重构了报告的正文部分，因此有了本文和github仓库。参考 SJTU Thesis Proposal 上海交大开题报告模板" }, { "title": "MacOS通过QEMU启动openEuler RISC-V", "url": "/posts/qemu-openeuler-riscv/", "categories": "Linux", "tags": "Linux, RISC-V", "date": "2024-03-25 00:00:00 +0800", "snippet": "安装qemu安装依赖：brew install gawk gnu-sed gmp mpfr libmpc isl zlib expat安装qemu：brew install qemu下载openEuler的镜像从网站中选择版本，这里我选择了openEuler-23.09-V1-riscv64(网址)如果想要桌面系统，记得下载带有xfce的保证当前目录下有一个启动脚本.sh，一个bin文件和一个zst文件，解压缩zst文件，并将sh文件和bin文件和解压缩后的qcow2文件放在一个文件夹中启动openEuler执行脚本启动： bash start_vm_xfce.sh执行后发现脚本中两处参数失效，查看qemu-system-riscv64 --help和qemu-system-riscv64 -audiodev help的相关信息后，修改参数为：... -display cocoa,show-cursor=on \\ -audiodev coreaudio,id=snd0 \\启动后，默认的用户openeuler，密码是openEuler12#$参考 oerv-pretask（一）通过 QEMU 仿真 RISC-V 环境并启动 openEuler RISC-V 系统，设法输出 neofetch 结果并截图提交 - 知乎 (zhihu.com) Running 64- and 32-bit RISC-V Linux on QEMU — RISC-V - Getting Started Guide (risc-v-getting-started-guide.readthedocs.io)" }, { "title": "解决MacOS上zsh在git add时tab补全卡住的问题", "url": "/posts/pain-in-the-ass/", "categories": "MacOS", "tags": "MacOS", "date": "2024-03-25 00:00:00 +0800", "snippet": "问题描述在MacOS上，通过zsh在git仓库中使用git add命令并用tab键补全路径时卡住。尝试Git tab completion not working in zsh on mac - stackoverflow排名靠前的方法无效。之前使用Warp新的终端工具来绕过这个问题。解决方案根据stackoverflow上2024最新的回答，在~/.zshrc中添加：# Init Homebrew to get `HOMEBREW_PREFIX`eval \"$(brew shellenv)\"# Delete brew's objectively worse git completionremove_conflicting_git_completions() { local git_completion_bash=\"$HOMEBREW_PREFIX/share/zsh/site-functions/git-completion.bash\" local git_completion_zsh=\"$HOMEBREW_PREFIX/share/zsh/site-functions/_git\" [ -e \"$git_completion_bash\" ] &amp;&amp; rm \"$git_completion_bash\" [ -e \"$git_completion_zsh\" ] &amp;&amp; rm \"$git_completion_zsh\"}# This needs to run every time since brew sometimes brings those files backremove_conflicting_git_completions# Add Homebrew's site functions to fpath (minus git, because that causes conflicts)# This will give you autocomplete for _other_ things you installed# from brew (like `just`, or `exa`, or `k6`)fpath=($HOMEBREW_PREFIX/share/zsh/site-functions $fpath)执行一次后即可修复，即使执行后删去上文中的代码也没事,依旧可正常补全，不会再卡住。" }, { "title": "linux-system()函数笔记", "url": "/posts/linux-system-function/", "categories": "Linux", "tags": "Linux", "date": "2023-11-01 00:00:00 +0800", "snippet": "linux-system()函数 小结： system执行命令的期间主进程收到的SIGINT和SIGQUIT会被忽略（posix.1规定），原因是posix不希望主进程响应system子进程的SIGINT和SIGQUIT信号 非阻塞版本：popen() Do not use system() from a program with set-user-ID or set-group-ID privileges 返回值多，小心处理 执行过程：fork ()-&gt;exec ()-&gt;waitpid () 子进程是父进程的副本，可能会增加内存消耗使用建议：1、建议 system () 函数只用来执行 shell 命令，因为一般来讲，system () 返回值不是 0 就说明出错了；2、建议监控一下 system () 函数的执行完毕后的 errno 值，争取出错时给出更多有用信息；3、建议考虑一下 system () 函数的替代函数 popen ()；风险安全问题在编写具有SUID/SGID权限的程序时请勿使用system函数，system函数会继承环境变量，通过环境变量可能会造成系统安全的问题。 Do not use system() from a program with set-user-ID or set-group-ID privileges, because strange values for some environment variables might be used to subvert system integrity. Use the exec(3) family of functions instead, but not execlp(3) or execvp(3). system() will not, in fact, work properly from programs with set-user-ID or set-group-ID privileges on systems on which /bin/sh is bash version 2, since bash 2 drops privileges on startup. (Debian uses a modified bash which does not do this when invoked as sh.)详解：SUID 是 Set User ID，SGID 是 Set Group ID的意思。在 Linux 系统中，这两种权限主要用于控制文件访问。当一个程序被设置了 SUID 或 SGID 权限后，用户在执行该程序时，会临时获得该程序文件的所有者或所属组的权限¹²⁷⁸。SUID/SGID 权限主要应用在二进制可执行文件上¹²。例如，当普通用户需要修改自己的密码时，他们需要访问 /etc/shadow 文件，但这个文件通常只有 root 用户才有读写权限。此时，如果 passwd 命令（用于修改密码）被设置了 SUID 权限，并且该命令的所有者是 root 用户，那么普通用户在执行 passwd 命令时就会临时获得 root 用户的权限，从而可以修改 /etc/shadow 文件¹²。然而，在编写具有 SUID/SGID 权限的程序时使用 system 函数可能会带来安全问题。因为 system 函数会继承环境变量，攻击者可能通过修改环境变量来执行恶意命令。例如，攻击者可以通过修改 PATH 环境变量，使得具有 SUID/SGID 权限的程序在调用 system 函数执行某个系统命令时，实际上执行的是攻击者提供的恶意程序。因此，为了避免这种潜在的安全风险，我们通常建议在编写具有 SUID/SGID 权限的程序时避免使用 system 函数。⁹参考Bing 2023/11/1：(2) linux：SUID、SGID详解 - 知乎. https://zhuanlan.zhihu.com/p/166468556. (3) Linux中文件特殊权限suid、sgid、sticky（有图详细讲解 …. https://blog.csdn.net/MssGuo/article/details/120754324. (4) Linux特殊权限之SUID - 简书. https://www.jianshu.com/p/4ea1e6aa2aa7. (5) Linux SetGID（SGID）文件特殊权限用法详解 - C语言中文网. https://c.biancheng.net/view/870.html. (6) 具有 SUID/SGID 权限的命令运行状态-CSDN博客. https://blog.csdn.net/wangzengdi/article/details/32173353. (7) LINUX中suid/guid指什么？-CSDN博客. https://bing.com/search?q=SUID%2FSGID权限是什么意思. (8) Linux 特殊权限 SUID,SGID,SBIT - sparkdev - 博客园. https://www.cnblogs.com/sparkdev/p/9651622.html. (9) LINUX中suid/guid指什么？-CSDN博客. https://blog.csdn.net/chimu9074/article/details/100605347. (10) LINUX中suid,sgid是用来干嘛的？怎么使用？ - 百度知道. https://zhidao.baidu.com/question/189879510.html.案例-SIGCHLD 信号处理方式变更导致\"No child processes\"【C/C++】Linux下system()函数引发的错误 - 恋恋美食的个人空间 - OSCHINA - 中文开源技术交流社区相关知识为何会阻塞SIGCHLD 信号在Linux中fork的子进程结束后，内核会向其父进程发送SIGCHLD信号，即system函数的调用者，system源码中父进程是调用waitpid函数来为变成僵尸的子进程进行回收，获得其结束状态，然后将这个结束状态返回给system函数的调用者。所以我们在调用system之前不能去注册SIGCHLD 信号的处理函数，如在信号处理函数中进行wait等操作，system函数中的 waitpid将可能获取不到子进程正确返回状态，因为子进程可能被信号处理函数抢先回收；以下是在实际项目中封装好的system模板函数：typedef void (*sighandler_t)(int);int os_system(const char *cmd){ int ret = 0; sighandler_t old_handler; old_handler = signal(SIGCHLD, SIG_DFL); ret = system(cmd); signal(SIGCHLD, old_handler); return ret;}old_handler =signal(SIGCHLD, SIG_DFL); 在调用system前将SIGCHLD信号的处理函数注册为SIG_DFL，在Linux 中SIG_DFL的作用就是忽略的意思;signal(SIGCHLD, old_handler);在调用完后将 SIGCHLD的处理函数恢复成调用前的处理函数。SIGCHLDSIGCHLD 是一个在 Unix-like 系统中的信号，当一个进程结束或者停止时，会发送 SIGCHLD 信号给其父进程。默认情况下，这个信号会被忽略。但是，如果父进程希望被告知其子进程的状态变化，那么它应该捕获这个信号¹。“SIGCHLD 将被阻塞”是指 SIGCHLD 信号被暂时挂起，不会立即送达到父进程。在 Unix-like 系统中，可以通过信号掩码来阻塞特定的信号。当一个信号被阻塞时，即使该信号产生了，也不会立即送达到进程，而是处于未决状态。只有当该信号被解除阻塞后，才会送达到进程⁴。例如，在某些情况下，我们可能希望在父进程完成对 SIGCHLD 信号处理函数的设置之前阻塞 SIGCHLD 信号。这样可以确保在所有子进程结束之前，父进程能够完成对 SIGCHLD 信号的处理函数的设置。否则，如果所有子进程都结束了，而父进程还没有完成设置，则此时的 SIGCHLD 信号都会被忽略，从而导致子进程不能被父进程回收¹。参考Bing 2023/11/1： (1) SIGCHLD信号-CSDN博客. https://blog.csdn.net/qq_33883085/article/details/89325396. (2) system阻塞SIGCHLD信号原因_sigchld system-CSDN博客. https://blog.csdn.net/wwlhsgs/article/details/50721681. (3) SIGCHLD信号详解 - 掘金. https://juejin.cn/post/7245145631181996090. (4) linux下wait/waitpid处理僵死进程详解(SIGCHLD信号) - 知乎. https://zhuanlan.zhihu.com/p/272700092.fork不意味着子进程会消耗和父进程一样多的物理内存在 Unix-like 系统中，fork() 函数会创建一个新的进程，这个新进程是父进程的一个副本。但是，这并不意味着子进程会消耗和父进程一样多的物理内存¹²³⁴。实际上，大多数现代的 Unix-like 系统（包括 Linux）在实现 fork() 函数时，采用了一种称为写时复制（Copy-On-Write，简称 COW）的技术来优化内存使用⁵。当调用 fork() 函数创建子进程时，子进程的用户级虚拟地址空间会和父进程共享相同的物理页帧¹²³⁴。也就是说，父进程和子进程在内存中的代码段、数据段、堆段和栈段都指向相同的物理内存⁵。只有当父进程或子进程试图修改某个共享页面时，系统才会为修改操作的进程创建该页面的一个副本⁵。这样，每个进程都有自己独立的地址空间，而且只有在必要时才会复制内存页面，从而有效地节省了物理内存⁵。所以，虽然 fork() 会创建一个新的进程，但并不会立即消耗和父进程一样多的物理内存¹²³⁴⁵。参考Bing 2023/11/1： (1) 进程系统调用——fork函数深入理解(代码演示) - 知乎. https://zhuanlan.zhihu.com/p/422928238. (2) fork（）函数 - 知乎. https://zhuanlan.zhihu.com/p/422099192. (3) 【Linux】关于理解fork()函数的简单例子 - 知乎. https://zhuanlan.zhihu.com/p/91616048. (4) Linux中fork函数的作用及用法-CSDN博客. https://blog.csdn.net/weixin_40853073/article/details/81873398. (5) fork之后父子进程的内存关系_父进程 fork子进程 内存-CSDN博客. https://blog.csdn.net/shreck66/article/details/47039937.参考 Bing AI Linux下的system函数应该这样用 - 知乎 (zhihu.com) [🌟]宏伟精讲·linux system()函数完全解密 - 知乎 (zhihu.com) linux：SUID、SGID详解 - 知乎 (zhihu.com)" }, { "title": "【论文笔记】Billion-scale similarity search with GPUs", "url": "/posts/faiss/", "categories": "DBMS", "tags": "Paper, Vector Database, Similarity Search, k-selection", "date": "2023-10-27 00:00:00 +0800", "snippet": "BriefIn this paper, Faiss aims to utilize GPUs for similar search find workload by a design of k-selection. It is based on the method of product quantization (PQ) codes, which origin proposal is IVFADC. Therefore, it is able to handle billion-scale datasets or non-exhaustive search. For the YFCC100M dataset, Faiss takes in 35 minutes to construct a high accuracy k-NN graph on 95 million images. Construction of a graph connecting 1 billion vectors in less than 12 hours on 4 Maxwell Titan X GPUs.This paper makes three main contributions: A GPU k-selection algorithm, operating in fast register memory and flexible enough to be fusable with other kernels, which the paper provide a complexity analysis; A near-optimal algorithmic layout for exact and approximate k-nearest neighbor search on GPU; A range of experiments that show that these improvements outperform previous art by a large margin on mid- to large-scale nearest-neighbor search tasks, in single or multi-GPU configurations.BackgroundFaiss is an open-source clustering and similarity search library developed by Facebook AI, providing efficient similarity search and clustering for dense vectors on RAM-only. It supports searches for billions of vectors and is currently the most mature nearest neighbor search library. It contains multiple algorithms for searching for vector sets of any size for which is determined by RAM memory.Binary codes and quantization methods are two most popular vector compression categories. Both two search neighbors that does not require reconstructing the vectors.Reference J. Johnson, M. Douze, and H. Jégou, “Billion-scale similarity search with gpus,” IEEE Transactions on Big Data, vol. 7, no. 3, pp. 535–547, 2019, doi: 10.1109/TBDATA.2019.2921572." }, { "title": "【论文笔记】Automatic Database Knob Tuning: A Survey", "url": "/posts/knob-tuning/", "categories": "DBMS", "tags": "Paper, AI4DB, Knob Tuning", "date": "2023-10-20 00:00:00 +0800", "snippet": "BriefThe key idea of automatic knob tuning is that, with the help of machine learning techniques, it is reasonable to collect knob tuning data, leverage these data to train a knob tuning model, and utilize the tuning model to recommend knob settings for new similar scenarios, so as to achieve the optimization objectives.ProblemsTune objectives: performance. (1) throughput (2) latency improve resource utilization or reduce maintenance costs without sacrificing performance.Most existing machine learning methods cannot directly provide recommend high-quality knob settings for new tuning tasks and have a long time to train from scratch. Therefore, transfer techniques need to be reviewed.Methods and ChallengesKnob selection includes empirical-based strategies and ranking-based strategies. They rely on some simple assumptions (e.g., assuming the linear relations between knobs and performance). Second, they cannot capture the correlations of knobs. Third, they may miss valuable knobs. Moreover, they rely on a large number of samples to find important knobs and may cause performance regression when the workloads change.Tuning features are broadly divided into workload features and database metric features. It is vital to design an interpretable feature selection methodology that can automatically select tuning features with reasonable justifications. Besides, apart from historical workloads, there are some techniques that help to predict future workload trends, which can be more useful in tuning the configuration knobs.As the knob tuning problem is NP-hard, existing tuning methods have four categories, i.e., (i) heuristic methods, (ii) Bayesian optimization-based methods, (iii) deep-learning-based methods, (iv) reinforcement-learning-based methods. Open challenges involves in data distribution aware configuration tuning, incremental configuration tuning and tuning performance prediction.It is vital to achieve practical learned tuning methods in real scenarios. Thus, transfer techniques are proposed to support dynamic scenarios at different levels. It is challenging to manually select tuning models and adjust the parameters between various ML models. Moreover, it is hard to evaluate whether a learned model is effective in most scenarios, for which a validation model is required.The paper also discuss how to deploy existing knob tuning techniques for relational databases and big-data systems. In addition, the paper discuss three configuration tuning problems beyond knobs, including index tuning, view tuning, and partition tuning.Reference X. Zhao, X. Zhou, and G. Li, “Automatic Database Knob Tuning: A Survey,” IEEE Transactions on Knowledge and Data Engineering, 2023, Accessed: Oct. 02, 2023. [paper]" }, { "title": "【论文笔记】Building An Elastic Query Engine on Disaggregated Storage", "url": "/posts/snowflake/", "categories": "DBMS", "tags": "Paper, OLAP, Cloud Native, Disaggregated Storage", "date": "2023-10-13 00:00:00 +0800", "snippet": "BriefSnowflake decouple compute and persistent storage, providing warehousing as a service. It is in production for over 7 years.DesignIntermediate data is generated by query operators (e.g., joins) and is usually consumed by nodes participating in executing that query. It is short-lived, and prefer low-latency high-throughput access.As nodes are added and removed, the ephemeral storage system does not require data repartitioning or reshuffling. Tasks executing query operations (e.g., joins) on a given compute node write intermediate data locally; and, tasks consuming the intermediate data read it either locally or remotely over the network (depending on the node where thetask is scheduled).Elasticity: Persistent storage - easy, offloaded to S3 Compute - easy, pre-warmed pool of VMs Ephemeral storage - challenging, due to co-location with computeKey finding: Customers submit a wide variety of query types. Intermediate data sizes can vary over multiple orders of magnitude across queries. Even with a small amount of local storage capacity, skewed access distributions and temporal access patterns common in data warehouses enable reasonably high average cache hit rates (60-80% depending on the type of query) for persistent data accesses. Several of our customers exploit our support for elasticity (for 20% of the clusters). Peak resource utilization can be high, the average resource utilization is usually low.Reference M. Vuppalapati, J. Miron, R. Agarwal, D. Truong, A. Motivala, and T. Cruanes, “Building an elastic query engine on disaggregated storage,” in 17th USENIX Symposium on Networked Systems Design and Implementation (NSDI 20), 2020, pp. 449–462. Accessed: Oct. 02, 2023. [paper] [video]" }, { "title": "【论文笔记】Polynesia: Enabling High-Performance and Energy-Efficient Hybrid Transactional/Analytical Databases with Hardware/Software Co-Design", "url": "/posts/polynesia/", "categories": "DBMS", "tags": "Paper, HTAP, PIM", "date": "2023-10-03 00:00:00 +0800", "snippet": "BriefNowadays, many applications need to perform real-time data analysis using an HTAP system. An ideal HTAP system should have three properties: Data freshness and consistency. Workload-specific optimization. Performance isolation.However, prior works cannot achieve all these properties. The paper divides the system into transactional and analytical processing islands, which enables workload-specific optimizations and performance isolation. It introduces Polynesia, a novel hardware/software cooperative design for in-memory HTAP databases. Polynesia implements custom algorithms and hardware to reduce the costs of data freshness and consistency. It also exploits PIM for analytical processing to alleviate data movement. In result, Polynesia has average transactional/analytical throughput improvements of 1.7x/3.7x and 48% reduction on energy consumption, compared to three state-of-the-art HTAP systems.Design and EvaluationThe key idea of Polynesia is partition computing resources into two types of isolated and specialized processing islands. By isolating transactional islands from analytical islands, Polynesia apply workload-specific optimizations to each island, avoid high main memory contention, and design efficient data freshness and consistency mechanism without incurring high data movement costs.Reference Boroumand, A., Ghose, S., Oliveira, G.F., Mutlu, O., 2022. Polynesia: Enabling High-Performance and Energy-Efficient Hybrid Transactional/Analytical Databases with Hardware/Software Co-Design, in: 2022 IEEE 38th International Conference on Data Engineering (ICDE). IEEE, pp. 2997–3011. [paper][video1-short][video2-long]" }, { "title": "【论文分享】Pando: Enhanced Data Skipping with Logical Data Partitioning", "url": "/posts/pando/", "categories": "DBMS", "tags": "Paper, Data Skipping", "date": "2023-09-23 00:00:00 +0800", "snippet": "Learned LayoutsQd-treeMTOPandoResults*dip: Data-induced predicates is a concept in the database field that uses data statistics to convert predicates on a table into data-induced predicates suitable for joining tables. Doing this can significantly speed up multi-relational queries because the benefits of predicate pushdown can now be applied to tables other than the table with the predicate.SummaryPando: metadata-rich data layout framework.Significant reduction in the amount of I/O performed jointly optimizing the physical layout of the data multiple correlation-aware logical partitionings(not covered)参考 Yang, Z. et al. 2020. Qd-tree: Learning data layouts for big data analytics. Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data (2020), 193–208. [paper] [video] [⭐] Ding, J. et al. 2021. Instance-optimized data layouts for cloud analytics workloads. Proceedings of the 2021 International Conference on Management of Data (2021), 418–431. [paper] [video] Sudhir, S. et al. 2023. Pando: Enhanced Data Skipping with Logical Data Partitioning. Proceedings of the VLDB Endowment. 16, 9 (2023), 2316–2329. [paper] " }, { "title": "【论文笔记】Optimal column layout for hybrid workloads", "url": "/posts/casper/", "categories": "DBMS", "tags": "Paper, HTAP, Data Layout, Hybrid Workloads", "date": "2023-09-22 00:00:00 +0800", "snippet": "IntroductionFor HTAP databases, there are two conflicting goals: Append new data for fast ingestion. Organize/sort data for fast querying. Ideally, a HTAP database should achieve these goals by having dense sorted columns to support scans and selective queries with minimal update cost. However, what is usually a good data layout for an update-heavy workload, is not well-suited for a read-mostly one and vice versa.Therefore, the paper introduces Casper, a storage engine has workload-aware optimal colum layout, which fixes the problem of using fix method to handle hybrid workloads.Design PrimitivesNormally, there are three kinds of data organizations: append order, sorted and partitioned.Global data layout decisions miss opportunities for fine-grained optimization. Meanwhile, optimal layout through fine-grained local decisions has massive performance benefits. To achieve this, the system depends on the exact workload. For append order and sorted organization, they apply global decisions. The partitioned allows for different fine-grained local decisions in different parts of the domain. Casper achieve that by using access frequency method.In Figure 1, no order type is good for scans and for appends. Sorted + delta type is good for selective queries and a few updates. Paper assumes that partitions wih non-overlapping ranges. And each partition internally does not have to be sorted. For partitioning, under normal circumstances, data is tightly packed. The insertion operation first locates the appropriate partition position, then attempts to create a vacant slot within that partition to insert the data. A method known as “Ripple-Insert” is employed for this purpose. To make room for the new data, each partition steals a position from the head of the subsequent adjacent partition. The adjacent partition then continues to seize a position from its subsequent partition, and so on. This process facilitates the overall adjustment of the data, propagating much like ripples in water.DesignThe partitioning of data is fundamentally a division of contiguous blocks. This is achieved by marking whether a block at a certain position is a partition boundary. Thus, the expression and output of partition division involve outputting the binary values corresponding to the indices of the boundary blocks in the form of a bit-vector.The system maximize performance using run-time workload knowledge.Evaluation and ConclusionFrom Figure 4, it can be learned that delta buffers are enough for read-mostly workload. Casper is suitable for update-mostly workload.Casper, a storage engine has workload-aware optimal colum layout, co-optimize reads and writes through tunable partitioning. It further explores ghost values to insert with minimal data movement. And it offers optimal performance using workload-driven fine-grained decisions.Reference Athanassoulis, M. et al. 2019. Optimal column layout for hybrid workloads. VLDB, 12(13): 2393–2407. 2019 [paper][video] Optimal Column Layout for Hybrid Workloads reviews. https://zhuanlan.zhihu.com/p/400225192. Accessed: 2023-09-21." }, { "title": "折腾记录：type stub problem on vscode for python", "url": "/posts/type-stub-of-python/", "categories": "Tool", "tags": "Type Stub, Python", "date": "2023-08-09 00:00:00 +0800", "snippet": "问题Env OS: MacOS Monterey(intel) &amp; Ubuntn22.04 LTS IDE: Vscode 1.80.2 x64 Language: Python 3.11.3 Language server: pylance 0.6.0 Third-party library: Pillow 10.0.0问题描述代码能跑，但如何让type inferring识别width， 从而方便自动补全等功能。解决办法：不纠结TL;DR:库本身的问题 importing packages without proper stubs/hints五个方法： 换pycharm + 插件（vim/vscode keymap）（大部分支持，也有不能补全的时候但少一些） 关闭pylance，岁月静好（解决不了问题，就不去出现问题的地方） type assert (有时能解决问题) 关闭报错信息(不看到恼人的波浪号) 手动增加.pyistub files（理论上能解决问题，目测工作量大，相当于成为库作者）在vscode上没有开箱即用的解决方案，所以目前的办法（2023.8.9）——不纠结，或者换pycharm。key word: python, pylance, type stub完整的讨论：Cannot access member “to” for type “None” Member “to” is unknownPylance(reportGeneralTypeIssues) · Issue #3494 · microsoft/pylance-release (github.com)具体的例子：Pyspark: cannot access member “config” for type “classproperty” · Issue #4577 · microsoft/pylance-release (github.com)做过的尝试 换IDE: pycharm 换 language server: jedi 试不同的库（pillow &amp; python-redmine） 在两个机子上复现（mac &amp; linux） 换不同的python版本(python3.11 &amp; python 3.8)related concepttype stub problemPython type stubs are a set of type stubs for popular Python packages. These are works in progress from the Microsoft Python team and others, with the intent that they are contributed to typeshed or to the associated packages once sufficiently complete. They are used to ensure that packages have high-quality type annotations. In cases where this must be done through type stubs, they are contributing stubs to typeshed. This repository contains their “work in progress”. Once the stubs for a package meet the requirements of typeshed, they will contribute them to typeshed and delete them from this repository1.In case you are facing an issue with Pylance, it is possible that it is a type stub problem. The type Pylance is using for the class may be coming from a type stub2.typeshedTypeshed is a collection of library stubs for Python, with static types. It contains external type annotations for the Python standard library and Python built-ins, as well as third-party packages contributed by people external to those projects1. This data can be used for static analysis, type checking, or type inference2. If you’re using a type checker (such as mypy, pyright, pytype, PyCharm, etc.), you don’t need to interact with the typeshed repository at all: a copy of the standard library part of typeshed is bundled with type checkers2." }, { "title": "【论文分享】Bigtable", "url": "/posts/bigtable/", "categories": "DBMS", "tags": "NoSql, Paper", "date": "2023-04-15 00:00:00 +0800", "snippet": "背景论文数据模型系统架构LSM-tree性能评估总结参考拓展阅读Cloud Data Center CS 494: Cloud Data Center Systems · Home Jeff Dean-2009-Slides (cornell.edu) p43-p66, LADIS’09 The Google File System (GFS) (slideshare.net) The Google Chubby lock service for loosely-coupled distributed systems (slideshare.net) The google MapReduce (slideshare.net)Bigtable awesome-bigtable: Delightful list of Google Bigtable resources, packages and interesting finds. (github.com) 深入浅出hbase和bigtable - 知乎 (zhihu.com) The Secret Sauce Behind NoSQL: LSM Tree - YouTube Bloom Filters - Algorithms You Should Know #2 - Real-world Examples – YouTubeColossus 谷歌Colossus文件系统的设计经验 - 腾讯云开发者社区 A peek behind Colossus, Google’s file system - Google Cloud Blog Google File System及其继任者Colossus - Blog - Levy’s Ink参考资料 邝宇恒(2009)，Dreaming Infrastructure 我的架构学习笔记，https://www.slideshare.net/kyhpudding/dreaming-infrastructure [⭐]Jeff Dean(2005), BigTable: A Distributed Structured Storage System, https://www.youtube.com/watch?v=2cXBNQClehA&amp;ab_channel=FedericoConte 吴垚(2022)，数据浪潮，人民邮电出版社, ISBN 9787115579249 Sam Zuhuruddin(2017), Bigtable in action, Google Cloud Next， https://www.youtube.com/watch?v=KaRbKdMInuc&amp;t=469s&amp;ab_channel=GoogleCloudTech Girdharee Saran (2021), What is a BigTable? https://www.whizlabs.com/blog/what-is-a-bigtable/ Romain Jacotin(2014), Lecture: The Google Bigtable, https://www2.cs.uic.edu/~brents/cs494-cdcs/slides/thegooglebigtable.pdf Shivaram Venkataraman(2018), CS 744: Big Data Systems, https://pages.cs.wisc.edu/~shivaram/cs744-slides/cs744-bigtable.pdf ByteByteGo(2021), The Secret Sauce Behind NoSQL: LSM Tree - YouTube [⭐] J. Dean, “Designs, lessons and advice from building large distributed systems,” Keynote from LADIS, vol. 1, 2009.http://iepg.org/iepg/2009-11-ietf76/dean-keynote-ladis2009.pdf 邝宇恒（2020），BigTable 有什么值得称道（牛）的地方？知乎, https://www.zhihu.com/question/19551534/answer/116874719" }, { "title": "MapReduce", "url": "/posts/mapreduce/", "categories": "Distributed System", "tags": "MapReduce", "date": "2022-08-01 00:00:00 +0800", "snippet": "论文(TODO)参考资料 6.824 讲义 6.824 视频 论文 中文翻译 谭新宇的博客实现(TODO)" }, { "title": "C++: 避免使用单例模式", "url": "/posts/singleton/", "categories": "C++", "tags": "C++, Singleton, Design Pattern", "date": "2022-05-23 00:00:00 +0800", "snippet": "避免使用单例模式：全局变量避免传统单例模式的代码实现，但注意单例的抽象方法是可取的。理由： 全局变量 不利于单元测试 单例模式的滥用单例模式本质上是一个大号的全局变量。全局变量没有访问限制，因为它没有所有权，这导致程序员很难推断全局变量的状态，当你调用基于一个全局变量函数时，可能另一个实例在你没有意识到的情况下，也调用了另一个基于该全局变量的函数。没有所有权也带来了另一个问题——全局变量的构造顺序不被标准所决定。换句话说，在不同文件的非局部变量的初始化顺序和析构顺序是未定义的（undefined），这个问题也被称为Static initialization order fiasco。单例模式也会掩盖依赖关系，使单元测试变得复杂，我们很难去mock一个单例模式产生的对象，夸张点说，使用了单例模式就没有单元可言。Mihai在博客中也提到一个例子，实际生产中，往往不止一个对象可以作为单例，比如日志和文件系统，他们之间还有依赖关系。日志需要文件系统打开文件去记录信息，而文件系统需要日志记录打开了哪些文件。在处理这些情况时，单例模式是很棘手的。Rainer在书中提到了单例模式不好的声誉也来自于程序员对它的滥用，很多人仅仅是为想要运用设计模式而应用单例模式，以至于会出现整个程序都是单例模式的情况。替代方法 利用命名空间 依赖注入模式 异步回调1.利用命名空间一个替代单例模式的思路是将类中所以的函数和数据成员都变成static，但这样有些过度设计了，可以直接用命名空间来代替类，这样从类的写法：class Manager{public: static int blimp_count(); static void add_more_blimps(int); static void destroy_blimp(int);private: static std::vector&lt;Blimp&gt; blimps; static void deploy_blimp();};转变成：namespace Manager{ int blimp_count(); void add_more_blimps(int); void destroy_blimp(int);}注意这种写法也要留心上文提到的Static initialization order fiasco问题2.使用依赖注入模式使用依赖注入（dependency injection）模式来替代，更详细的介绍看Marc（2021）在书中的代码，这个例子中ILogger的实例通过Foo的构造函数被注入到类中：class Foo{public: explicit Foo(ILogger&amp; logger): m_logger { logger } {} void doSomething() { m_logger.log(\"Hello dependency injection!\", ILogger::LogLevel::Info); }private: ILogger&amp; m_logger;}当Foo的实例被创建时，一个ILogger实例就会被注入到其中：Logger concreteLogger { \"log.out\"};concreteLogger.setLogLevel(ILogger::LogLevel::Debug);Foo f { concreteLogger };f.doSomething();3.改进：利用异步回调的方式Mihai(2018)在博客中提到受boost和qt信号启动的异步回调的方法：class Logger{public: void Log(std::string const&amp; message) { std::cout &lt;&lt; message &lt;&lt; '\\n'; }};class Debugger{public: void Update() { sigLog.emit(\"Debugger updating\") } Signal&lt;void(std::string)&gt; sig_Log;};class Profiler{public: Profiler::Profiler() void Update() { sig_Update.emit() sig_Log.emit(\"Profiler updating\") } Signal&lt;void&gt; sig_Update; Signal&lt;void(std::string)&gt; sig_Log;};class Game{public: Game() : m_logger() , m_debugger() , m_profiler() , m_debuggerLoggerConnection(m_debugger.sig_Log.connect(&amp;Logger::Log, m_logger)) , m_profilerLoggerConnection(m_profiler.sig_Log.connect(&amp;Logger::Log, m_logger)) , m_profilerDebuggerConnection(m_profiler.sig_Update.connect(&amp;Debugger::Update, m_debugger)) {} void Update() { m_profiler.Update(); }private: Logger m_logger; Debugger m_debugger; Profiler m_profiler; Connection m_debuggerLoggerConnection; Connection m_profilerLoggerConnection; Connection m_profilerDebuggerConnection;};需要单例的话：c++11的实现如果需要使用单例模式的话，可以选择利用c++11 magic statics特性实现的Meyers Singleton： #include &lt;iostream&gt; #include &lt;cassert&gt; ​ class Singleton { public: static Singleton&amp; Instance() { static Singleton instance; return instance; } public: Singleton(const Singleton&amp;) = delete; Singleton(Singleton&amp;&amp;) = delete; Singleton&amp; operator=(const Singleton&amp;) = delete; Singleton&amp; operator=(Singleton&amp;&amp;) = delete; private: Singleton() = default; ~Singleton() = default; }; ​ int main() { auto&amp; a = Singleton::Instance(); auto&amp; b = Singleton::Instance(); assert(&amp;a == &amp;b); ​ return 0; }magic statics的特性保证即使在多线程的情况下，test只会被初始化一次，然后这个实例会在main()函数返回之后被摧毁(在static destruction stage时)。Core Guidline 提到一个exception，就是将上文中的Meyers Singleton：X&amp; myX(){ static X my_x {3}; return my_x;}Less simple solutionCore Guidline 也提到当X 的析构涉及到需要同步行为时，我们必须使用一个复杂些的解决方案：X&amp; myX(){ static auto p = new X {3}; return *p; // potential leak}这样做的话，我们需要使用线程安全的方法手动delete掉这个对象。因为容易出错，所以使用这个方法有几个前提条件： myX是多线程的代码 X需要被摧毁（比如它需要释放资源），并且 X的析构函数需要同步执行【后注一】对于static member的初始化，C++标准保证，在同一个编译单元内的static member、global variable的静态初始化先于动态初始化。但是同为静态初始化或者同为动态初始化的时候，是按照其定义的顺序来进行的。 静态初始化是指zero initialization或者是用常量表达式初始化的情况，除此以外的都为动态初始化。 C++标准3.6.2节有相关描述。参考资料： Modern C++ Singleton Template - Code Review Stack Exchange The Issues With Singletons and How to Fix Them - Fluent C++ (fluentcpp.com) C++ Core Guidelines: aovid singletons shared_ptr和unique_ptr可否用于单例模式？ - 知乎 (zhihu.com) Marc Gregoire - Professional C++ - Wiley (2021) 第1106 - 1108页 Meyers, S, 1998. Effective C++. Reading, MA: Addison-Wesley What are drawbacks or disadvantages of singleton pattern? - Stack Overflow C++中多线程与Singleton的那些事儿 - origins - 博客园 (cnblogs.com) Rainer Grimm - C++ Core Guidelines Explained_Best Practices for Modern C++ - Addison-Wesley (2022)" }, { "title": "Xmake入门:通过xmake在vscode上编写c/c++项目", "url": "/posts/xmake-study/", "categories": "C++, 构建系统", "tags": "Study, C++, Xmake", "date": "2022-05-01 00:00:00 +0800", "snippet": "首先，学习下入门教程 第一步，【视频】Xmake 的安装和使用 第二步，【视频】在 VSCode 中使用 Xmake 进行 C/C++ 程序开发现在你就掌握xmake在vscode上的基本使用了，如果你想了解更多，欢迎查阅官方文档，我的笔记或许你也想了解一下cmake，这里有入门的介绍常见问题Q：win上的xmake如何安装？通过管理员身份下powershell的命令，Q：win上安装脚本时提示“因为在此系统上禁止运行脚本”解决办法因为在此系统上禁止运行脚本的解决 - 上官飞鸿 - 博客园 (cnblogs.com)【已解决】cnpm : 无法加载文件 C:UsersAppDataRoaming pmcnpm.ps1，因为在此系统上禁止运行脚本_华仔仔coding的博客-CSDN博客_cnpm无法加载" }, { "title": "VSCode/C++插件分享", "url": "/posts/vscode-plugin/", "categories": "Tool, VSCode", "tags": "Configuration, VSCode, C++", "date": "2022-04-23 00:00:00 +0800", "snippet": " 入门vscode推荐视频 使用 VS Code + Clangd + CMake 搭建 C/C++开发环境插件列表人人夸，一搜一大堆 project manager peacock vim gitlens Code Runner bookmarks todo tree tabout better comments Wakatime … 小众一些的 codecommand Running Visual Studio Code on Linux tabnine copilot error lens easy snippet snippet样例 快捷键设置 vscode snippet语法 [Snippets in Visual Studio Code] C++ helper 重要 xmake\\cmake 通过xmake在vscode上编写c/c++项目 编译选项:C++ Diagnostic Basics: Warnings, Assertions, Testing clangd clang-format clang-tidy 新版编译器 画图 draw.io PlantUML 小工具 String Manipulation Diff Viewer Sort Lines 附件仓库地址: https://github.com/yueneiqi/share_vscode_plugin" }, { "title": "Cmake学习历程", "url": "/posts/cmake-study/", "categories": "C++, 构建系统", "tags": "Study, C++, Cmake", "date": "2021-07-23 00:00:00 +0800", "snippet": " CMake - CS自学指南 (csdiy.wiki) xmake(官网)(教程) 现代C++中的高性能并行编程与优化-第一讲及其作业，再加上后续的现代CMake进阶指南参考资料： 《CMake菜谱（CMake Cookbook中文版）》 项目参考：cmu-db/bustub，整体框架 项目参考：config-loader，第三方库的链接方式 项目参考：ceph，对于spdk和dpdk等第三方库的链接方式，Find*.cmake和Build*.cmake" }, { "title": "【持续更新】C++学习资料", "url": "/posts/cpp-reference/", "categories": "C++", "tags": "Study, C++", "date": "2021-04-15 00:00:00 +0800", "snippet": "c++的资料非常得多，经典书单不再赘述，这里补充一些自己的体会。必看： hacking C++系统全面的c++学习网站，整合了很多资源，新手友好（Beginner’s Guide）能抓住modern C++(C++17)主干，方便入门的： cs106L【视频】斯坦福modern C++(C++17)课程 【快速学习C和C++，基础语法和优化策略(南科大计算机系)】 《现代 C++ 教程: 高速上手 C++ 11/14/17/20》》正如书名所说，精简的笔记进一步的学习资料： 候捷系列网课 【录播】现代C++中的高性能并行编程与优化（持续更新中） C++ Core Guidelines(2022) cpp-fundamentals-for-professionals （C++17）很好的讲义，很多可以在网页上运行的代码例子和小练习 Professional C++ 5th, 21年出的第五版，新的总是好的，全面系统，时常检索的参考书，中译本见《C++20高级编程(第5版)》。日常学习 cppcon 大牛们的讲座合集; Back to Basics系列适合作为入门学习的补充课程 C++ Weekly推荐文章合集 RAII move semantic Advantages of pass-by-value and std::move over pass-by-reference 什么是move？理解C++ Value categories，move， move in Rust C++: 再谈move，右值引用的由来 关于modern C++（C++11/14/17/20） 在modern c++中，singleton设计模式不推荐，应该尽量使用Dependency injection来替代，如果想用singleton，c++11之后的实现贴在这里 （2022.5）在clang和gcc上使用c++20 module特性很麻烦，intellisense 没有很好的支持，建议跳过这个部分" }, { "title": "2021Q1 计算机课程学习总结", "url": "/posts/cs-study-record/", "categories": "学习, 课程", "tags": "Study", "date": "2021-04-02 00:00:00 +0800", "snippet": "去年因为胡神关注了这些国外课程，但因为各种原因今年才刚刚开始，感觉如果英语阅读和听力不错，听听这些课程是很好的选择。记录一下自己学习的过程吧。The Missing Semester of Your CS Education听了很多次，每次都有新收获：第一次的时候刚想入门，听得懵懵的，写里面的作业，卡在bash脚本那里半天想不通就放弃了。后面用了linux和vim，再看这个课觉得帮助很大。对我来说，这个课更像是有着详细介绍的索引，想要现在吃透它是很难得，每次吸收一些，效率都会有提升，讲义里各种链接极大得丰富了这个课程，让我有了很多工具去装（工具控福音）。对于新手（我）来说，有用的点linux入门：讲义是很好的新手入门快查表。oh-my-zsh及shell脚本：看到zsh的自动补全就很想用，后来发现了oh-my-zsh，太香了，自带git状态显示，很多自带的插件，两下esc自动补sudo之类的。工具控狂喜，用它写zsh脚本也很方便，在都在一个.zsh文件里写个函数就行了。很多重复的工作，我现在都会写个命令来搞定。写脚本的时候我会用这个教程参考shell的语法，同时用shellcheck检查，这份shell的cheetsheet也挺有用的。一些示例。dotfile：第一次不理解，想搞但不知道是做啥的，到后面折腾vim和zsh的配置文件，再加上我在mac上装了linux虚拟机，怎么样同步配置是我一个很难受的点，这时候再看到dotfile就豁然开朗了，也走了很多坑，最后用了参考案例中的一个解决方案（我的笔记），中间我的linux崩了一次重装了，正好有了dotfile省了我很多事。git：配合oh-my-zsh的集成提示，很香。vim：第一次看的时候就只是看看，觉得挺厉害的但然并软，不练等于白看。后面开始使用vim，由此为契机再此看了这个课，觉得很有用，比起听教程学vim，不如做一下vimtutorial，查一下讲义，或者google一下，上手会快很多。入门之后，我也用了vimplus和vscode+vim插件，觉得后者更香，除了对纯键盘操作不感冒外，在安装vimplus本身和一些插件的各种错误也是给我留下了很深的怨念，但这不意味着vscode的上手配置就很轻松，也是挺费劲的。整体感觉下来，vscode更对我的口味吧。可惜了花在.vimrc的时间。vscode自带的终端虽然很方便，但性能有点拉垮，用tmux刚好可以弥补这个缺陷。正则表达式：推荐的练习不错，我挺爱用正则表达式的，grep -E。valgrind：正好我的入门语言是c和c++，这个工具在内存泄露和变量未初始化的问题上帮助很大。cs50x从2月中旬开始到4月2日结束，耗时：（至少）60小时++作业质量高，有阶梯，介绍详细，还有很多提示和帮助，适合自学完成作业+有助于熟悉vscode和c/c++的调试流程+TODO等注释标签思路写代码的习惯养成+覆盖内容广c python sql 前端三大件html css js非常好的入门导论课程，因为有基础，所以前半部分的课程跳着听着玩了，老师的课讲得很好，节奏很紧凑。题外话就是这个课的包装和影视制作都太强了，看到最后发现这是一个很大的团队在做就了然了，想制作出这种课程背后的付出却是很大CSE 251 Programming in C就我能做的作业而言（一半的lab和proj1），是一个难度简单，教程详细的c语言入门课程+详细的手把手教学 +Makefile的简易入门-后半部分的proj和lab依赖较老的库，很折腾了半天之后也没写成因为有基础，所以里面的一些作业和内容相对而言就太简单了。坑的一点就是，太想做proj2装了一天的环境也没装好，后面看见需要依赖图形库的作业就果断放弃，发现也就没啥能做的了，还是这门课太老了，想去装老的环境反而很繁琐，折腾了大半天也没成功，如果能做上的话，觉得会对这门课的评价会高更多（看起来很有意思），真的很想做电梯、车库和机器人啊….印象最深的该就是wumpus了吧" }, { "title": "汇编语言图解——一个简单的例子", "url": "/posts/assembly/", "categories": "学习, 杂记", "tags": "Study, Assembly", "date": "2021-03-03 00:00:00 +0800", "snippet": "总览main()func1()func2()内容重复，略func3()main()" }, { "title": "VSCode终端字体设置：Nerd Fonts", "url": "/posts/vscode-terminal/", "categories": "Tool, VSCode", "tags": "Configuration, VSCode", "date": "2021-02-27 00:00:00 +0800", "snippet": "在vscode上设置适配vim和oh-my-zsh的字体，从而解决字体不能正确显示的问题方法如下：1.安装Powerline fonts这是一个字体包的安装，也可以直接百度去下单个字体。Debian/Ubuntu等基于Linux的环境：sudo apt-get install fonts-powerline其他环境，如mac：# clone 下载git clone https://github.com/powerline/fonts.git --depth=1# install 安装cd fonts./install.sh# clean-up a bit 删除安装包cd ..rm -rf fonts（可选）查看字体库cd ~/Library/Fonts可以看到有很多带for powerline的字体，感兴趣也可以自己尝试一下，在vscode的使用格式如下文。2.设置在设置栏中输入：DroidSansMono Nerd Font参考：VScode终端字体设置 - 简书 (jianshu.com)转载：Powerline fonts 字体安装 - 简书 (jianshu.com)" } ]
